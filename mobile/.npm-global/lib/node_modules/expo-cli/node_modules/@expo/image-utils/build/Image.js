"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const mime_1 = __importDefault(require("mime"));
const Cache = __importStar(require("./Cache"));
const Download = __importStar(require("./Download"));
const Ico = __importStar(require("./Ico"));
const Jimp = __importStar(require("./jimp"));
const Sharp = __importStar(require("./sharp"));
const supportedMimeTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];
let hasWarned = false;
function resizeImagesAsync(buffer, sizes) {
    return __awaiter(this, void 0, void 0, function* () {
        const sharp = yield getSharpAsync();
        if (!sharp) {
            return Jimp.resizeBufferAsync(buffer, sizes);
        }
        return Sharp.resizeBufferAsync(buffer, sizes);
    });
}
function resizeAsync(imageOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        let sharp = yield getSharpAsync();
        const { width, height, backgroundColor, resizeMode } = imageOptions;
        if (!sharp) {
            const inputOptions = { input: imageOptions.src, quality: 100 };
            const jimp = yield Jimp.resize(inputOptions, {
                width,
                height,
                fit: resizeMode,
                background: backgroundColor,
            });
            const imgBuffer = yield jimp.getBufferAsync(jimp.getMIME());
            return imgBuffer;
        }
        try {
            let sharpBuffer = sharp(imageOptions.src)
                .ensureAlpha()
                .resize(width, height, { fit: resizeMode, background: 'transparent' });
            // Skip an extra step if the background is explicitly transparent.
            if (backgroundColor && backgroundColor !== 'transparent') {
                // Add the background color to the image
                sharpBuffer = sharpBuffer.composite([
                    {
                        // create a background color
                        input: {
                            create: {
                                width,
                                height,
                                // allow alpha colors
                                channels: 4,
                                background: backgroundColor,
                            },
                        },
                        // dest-over makes the first image (input) appear on top of the created image (background color)
                        blend: 'dest-over',
                    },
                ]);
            }
            return yield sharpBuffer.png().toBuffer();
        }
        catch ({ message }) {
            throw new Error(`It was not possible to generate splash screen '${imageOptions.src}'. ${message}`);
        }
    });
}
function getSharpAsync() {
    return __awaiter(this, void 0, void 0, function* () {
        let sharp;
        if (yield Sharp.isAvailableAsync())
            sharp = yield Sharp.findSharpInstanceAsync();
        return sharp;
    });
}
function getDimensionsId(imageOptions) {
    return imageOptions.width === imageOptions.height
        ? `${imageOptions.width}`
        : `${imageOptions.width}x${imageOptions.height}`;
}
function maybeWarnAboutInstallingSharpAsync() {
    return __awaiter(this, void 0, void 0, function* () {
        // Putting the warning here will prevent the warning from showing if all images were reused from the cache
        if (!hasWarned && !(yield Sharp.isAvailableAsync())) {
            hasWarned = true;
            console.log();
            console.log(chalk_1.default.bgYellow.black(`Using node to generate images. This is much slower than using native packages.`));
            console.log(chalk_1.default.yellow(`\u203A Optionally you can stop the process and try again after successfully running \`npm install -g sharp-cli\`.\n\u203A If you are using \`expo-cli\` to build your project then you could use the \`--no-pwa\` flag to skip the PWA asset generation step entirely.`));
        }
    });
}
function ensureImageOptionsAsync(imageOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const icon = Object.assign(Object.assign({}, imageOptions), { src: yield Download.downloadOrUseCachedImage(imageOptions.src) });
        const mimeType = mime_1.default.getType(icon.src);
        if (!mimeType) {
            throw new Error(`Invalid mimeType for image with source: ${icon.src}`);
        }
        if (!supportedMimeTypes.includes(mimeType)) {
            throw new Error(`Supplied image is not a supported image type: ${imageOptions.src}`);
        }
        if (!icon.name) {
            icon.name = `icon_${getDimensionsId(imageOptions)}.${mime_1.default.getExtension(mimeType)}`;
        }
        return icon;
    });
}
function generateImageAsync(options, imageOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const icon = yield ensureImageOptionsAsync(imageOptions);
        const cacheKey = yield Cache.createCacheKeyWithDirectoryAsync(options.projectRoot, options.cacheType, icon);
        const name = icon.name;
        let source = yield Cache.getImageFromCacheAsync(name, cacheKey);
        if (!source) {
            yield maybeWarnAboutInstallingSharpAsync();
            source = yield resizeAsync(icon);
            yield Cache.cacheImageAsync(name, source, cacheKey);
        }
        return { name, source };
    });
}
exports.generateImageAsync = generateImageAsync;
function generateFaviconAsync(pngImageBuffer, sizes = [16, 32, 48]) {
    return __awaiter(this, void 0, void 0, function* () {
        const buffers = yield resizeImagesAsync(pngImageBuffer, sizes);
        return yield Ico.generateAsync(buffers);
    });
}
exports.generateFaviconAsync = generateFaviconAsync;
//# sourceMappingURL=Image.js.map