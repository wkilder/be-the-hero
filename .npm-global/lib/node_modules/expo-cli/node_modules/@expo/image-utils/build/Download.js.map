{"version":3,"file":"Download.js","sourceRoot":"","sources":["../src/Download.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,wDAA0B;AAC1B,4DAA+B;AAC/B,gDAAwB;AACxB,oDAA4B;AAC5B,kDAA8B;AAC9B,gDAAwB;AACxB,gDAAwB;AAExB,sCAAsC;AACtC,MAAM,mBAAmB,GAA2B,EAAE,CAAC;AAEvD,SAAS,gBAAgB,CAAC,GAAW;IACnC,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC;AAED,SAAsB,wBAAwB,CAAC,GAAW;;QACxD,IAAI,GAAG,IAAI,mBAAmB,EAAE;YAC9B,OAAO,mBAAmB,CAAC,GAAG,CAAC,CAAC;SACjC;QACD,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YAC1B,mBAAmB,CAAC,GAAG,CAAC,GAAG,MAAM,aAAa,CAAC,GAAG,CAAC,CAAC;SACrD;aAAM;YACL,mBAAmB,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;SAChC;QACD,OAAO,mBAAmB,CAAC,GAAG,CAAC,CAAC;IAClC,CAAC;CAAA;AAVD,4DAUC;AAED,SAAsB,aAAa,CAAC,GAAW;;QAC7C,MAAM,UAAU,GAAG,eAAS,CAAC,SAAS,EAAE,CAAC;QAEzC,MAAM,QAAQ,GAAG,MAAM,oBAAK,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,GAAG,CAAC,CAAC;SACxE;QAED,yBAAyB;QACzB,MAAM,cAAc,GAAG,cAAI,CAAC,SAAS,CAAC,gBAAM,CAAC,QAAQ,CAAC,CAAC;QACvD,MAAM,SAAS,GAAG,cAAI,CAAC,IAAI,CAAC,UAAU,EAAE,cAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9E,MAAM,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,kBAAE,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC;QAErE,4EAA4E;QAC5E,MAAM,GAAG,GAAG,MAAM,cAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACvC,MAAM,IAAI,GAAG,GAAG;aACb,OAAO,EAAE;aACT,KAAK,CAAC,GAAG,CAAC;aACV,GAAG,EAAG,CAAC;QACV,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAC7B,MAAM,OAAO,GAAG,cAAI,CAAC,IAAI,CAAC,UAAU,EAAE,SAAS,IAAI,EAAE,CAAC,CAAC;YACvD,MAAM,kBAAE,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YAClC,OAAO,OAAO,CAAC;SAChB;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;CAAA;AA1BD,sCA0BC","sourcesContent":["import fs from 'fs-extra';\nimport fetch from 'node-fetch';\nimport path from 'path';\nimport stream from 'stream';\nimport temporary from 'tempy';\nimport util from 'util';\nimport Jimp from 'jimp';\n\n// cache downloaded images into memory\nconst cacheDownloadedKeys: Record<string, string> = {};\n\nfunction stripQueryParams(url: string): string {\n  return url.split('?')[0].split('#')[0];\n}\n\nexport async function downloadOrUseCachedImage(url: string): Promise<string> {\n  if (url in cacheDownloadedKeys) {\n    return cacheDownloadedKeys[url];\n  }\n  if (url.startsWith('http')) {\n    cacheDownloadedKeys[url] = await downloadImage(url);\n  } else {\n    cacheDownloadedKeys[url] = url;\n  }\n  return cacheDownloadedKeys[url];\n}\n\nexport async function downloadImage(url: string): Promise<string> {\n  const outputPath = temporary.directory();\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`It was not possible to download image from '${url}'`);\n  }\n\n  // Download to local file\n  const streamPipeline = util.promisify(stream.pipeline);\n  const localPath = path.join(outputPath, path.basename(stripQueryParams(url)));\n  await streamPipeline(response.body, fs.createWriteStream(localPath));\n\n  // If an image URL doesn't have a name, get the mime type and move the file.\n  const img = await Jimp.read(localPath);\n  const mime = img\n    .getMIME()\n    .split('/')\n    .pop()!;\n  if (!localPath.endsWith(mime)) {\n    const newPath = path.join(outputPath, `image.${mime}`);\n    await fs.move(localPath, newPath);\n    return newPath;\n  }\n\n  return localPath;\n}\n"]}