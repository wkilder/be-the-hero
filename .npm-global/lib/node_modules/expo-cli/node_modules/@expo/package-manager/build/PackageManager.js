"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_regex_1 = __importDefault(require("ansi-regex"));
const find_yarn_workspace_root_1 = __importDefault(require("find-yarn-workspace-root"));
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const split_1 = __importDefault(require("split"));
const stream_1 = require("stream");
const npm_package_arg_1 = __importDefault(require("npm-package-arg"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const detect_indent_1 = __importDefault(require("detect-indent"));
const detect_newline_1 = __importDefault(require("detect-newline"));
const ansi = `(?:${ansi_regex_1.default().source})*`;
const npmPeerDependencyWarningPattern = new RegExp(`${ansi}npm${ansi} ${ansi}WARN${ansi}.+You must install peer dependencies yourself\\.\n`, 'g');
const yarnPeerDependencyWarningPattern = new RegExp(`${ansi}warning${ansi} "[^"]+" has (?:unmet|incorrect) peer dependency "[^"]+"\\.\n`, 'g');
/**
 * Returns true if the project is using yarn, false if the project is using npm.
 *
 * @param projectRoot
 */
function isUsingYarn(projectRoot) {
    const workspaceRoot = find_yarn_workspace_root_1.default(projectRoot);
    if (workspaceRoot) {
        return fs_extra_1.default.existsSync(path_1.default.join(workspaceRoot, 'yarn.lock'));
    }
    return fs_extra_1.default.existsSync(path_1.default.join(projectRoot, 'yarn.lock'));
}
exports.isUsingYarn = isUsingYarn;
class NpmStderrTransform extends stream_1.Transform {
    _transform(chunk, encoding, callback) {
        this.push(chunk.toString().replace(npmPeerDependencyWarningPattern, ''));
        callback();
    }
}
class YarnStderrTransform extends stream_1.Transform {
    _transform(chunk, encoding, callback) {
        this.push(chunk.toString().replace(yarnPeerDependencyWarningPattern, ''));
        callback();
    }
}
class NpmPackageManager {
    constructor({ cwd, log }) {
        this.log = log || console.log;
        this.options = { cwd, stdio: ['inherit', 'inherit', 'pipe'] };
    }
    get name() {
        return 'npm';
    }
    installAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runAsync(['install']);
        });
    }
    addAsync(...names) {
        return __awaiter(this, void 0, void 0, function* () {
            const { versioned, unversioned } = this._parseSpecs(names);
            if (versioned.length) {
                yield this._patchAsync(versioned, 'dependencies');
                yield this._runAsync(['install']);
            }
            if (unversioned.length) {
                yield this._runAsync(['install', '--save', ...unversioned.map(spec => spec.raw)]);
            }
        });
    }
    addDevAsync(...names) {
        return __awaiter(this, void 0, void 0, function* () {
            const { versioned, unversioned } = this._parseSpecs(names);
            if (versioned.length) {
                yield this._patchAsync(versioned, 'devDependencies');
                yield this._runAsync(['install']);
            }
            if (unversioned.length) {
                yield this._runAsync(['install', '--save-dev', ...unversioned.map(spec => spec.raw)]);
            }
        });
    }
    versionAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            const { stdout } = yield spawn_async_1.default('npm', ['--version'], { stdio: 'pipe' });
            return stdout.trim();
        });
    }
    getConfigAsync(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const { stdout } = yield spawn_async_1.default('npm', ['config', 'get', key], { stdio: 'pipe' });
            return stdout.trim();
        });
    }
    // Private
    _runAsync(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`> npm ${args.join(' ')}`);
            const promise = spawn_async_1.default('npm', [...args], this.options);
            if (promise.child.stderr) {
                promise.child.stderr
                    .pipe(split_1.default(/\r?\n/, (line) => line + '\n'))
                    .pipe(new NpmStderrTransform())
                    .pipe(process.stderr);
            }
            return promise;
        });
    }
    _parseSpecs(names) {
        const result = { versioned: [], unversioned: [] };
        names
            .map(name => npm_package_arg_1.default(name))
            .forEach(spec => {
            if (spec.rawSpec) {
                result.versioned.push(spec);
            }
            else {
                result.unversioned.push(spec);
            }
        });
        return result;
    }
    _patchAsync(specs, packageType) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkgPath = path_1.default.join(this.options.cwd || '.', 'package.json');
            const pkgRaw = yield fs_extra_1.default.readFile(pkgPath, { encoding: 'utf8', flag: 'r' });
            const pkg = JSON.parse(pkgRaw);
            specs.forEach(spec => {
                pkg[packageType] = pkg[packageType] || {};
                pkg[packageType][spec.name] = spec.rawSpec;
            });
            yield fs_extra_1.default.writeJson(pkgPath, pkg, {
                spaces: detect_indent_1.default(pkgRaw).indent,
                EOL: detect_newline_1.default(pkgRaw),
            });
        });
    }
}
exports.NpmPackageManager = NpmPackageManager;
class YarnPackageManager {
    constructor({ cwd, log }) {
        this.log = log || console.log;
        this.options = {
            cwd,
            stdio: ['inherit', 'inherit', 'pipe'],
        };
    }
    get name() {
        return 'Yarn';
    }
    installAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runAsync(['install']);
        });
    }
    addAsync(...names) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runAsync(['add', ...names]);
        });
    }
    addDevAsync(...names) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runAsync(['add', '--dev', ...names]);
        });
    }
    versionAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            const { stdout } = yield spawn_async_1.default('yarnpkg', ['--version'], { stdio: 'pipe' });
            return stdout.trim();
        });
    }
    getConfigAsync(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const { stdout } = yield spawn_async_1.default('yarnpkg', ['config', 'get', key], { stdio: 'pipe' });
            return stdout.trim();
        });
    }
    // Private
    _runAsync(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`> yarn ${args.join(' ')}`);
            const promise = spawn_async_1.default('yarnpkg', args, this.options);
            if (promise.child.stderr) {
                promise.child.stderr.pipe(new YarnStderrTransform()).pipe(process.stderr);
            }
            return promise;
        });
    }
}
exports.YarnPackageManager = YarnPackageManager;
function createForProject(projectRoot, options = {}) {
    let PackageManager;
    if (options.npm) {
        PackageManager = NpmPackageManager;
    }
    else if (options.yarn) {
        PackageManager = YarnPackageManager;
    }
    else if (isUsingYarn(projectRoot)) {
        PackageManager = YarnPackageManager;
    }
    else {
        PackageManager = NpmPackageManager;
    }
    return new PackageManager({ cwd: projectRoot, log: options.log });
}
exports.createForProject = createForProject;
function getModulesPath(projectRoot) {
    const workspaceRoot = find_yarn_workspace_root_1.default(path_1.default.resolve(projectRoot)); // Absolute path or null
    if (workspaceRoot) {
        return path_1.default.resolve(workspaceRoot, 'node_modules');
    }
    return path_1.default.resolve(projectRoot, 'node_modules');
}
exports.getModulesPath = getModulesPath;
function getPossibleProjectRoot() {
    return fs_extra_1.default.realpathSync(process.cwd());
}
exports.getPossibleProjectRoot = getPossibleProjectRoot;
//# sourceMappingURL=PackageManager.js.map