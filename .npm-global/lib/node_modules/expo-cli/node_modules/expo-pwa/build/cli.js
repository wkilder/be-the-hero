#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const _1 = require(".");
const HTML_1 = require("./HTML");
const update_1 = __importDefault(require("./update"));
const packageJson = () => require('../package.json');
const program = new commander_1.Command(packageJson().name).version(packageJson().version);
const validateSourceArgument = (src, command) => {
    if (!src) {
        console.error(chalk_1.default.black.bgRed(`You must supply a valid image path or remote URL. Example:`));
        console.error(`\n   $ expo-pwa ${command} -i ./assets/icon.png`);
        console.error();
        process.exit(-1);
    }
};
function outputCommand(name, examples = []) {
    return program
        .command(`${name} [project-root]`)
        .option('-i, --input <file>', 'Input file to process')
        .option('-o, --output <path>', 'Output directory. Default: <project-root/>web')
        .option('-p, --public <path>', 'Public folder. Default: <output>')
        .on('--help', () => {
        if (!examples.length)
            return;
        console.log();
        console.log('Examples:');
        console.log();
        for (const example of examples) {
            console.log(`  $ expo-pwa ${name} ${example}`);
        }
        console.log();
    });
}
function assetCommand(name, examples = []) {
    return outputCommand(name, examples)
        .option('-r, --resize', 'Resize mode to use [contain, cover]', 'contain')
        .option('-c, --color', 'CSS background color for to use for the images (should be opaque).');
}
assetCommand('icon', ['--platform safari -i ./icon.png', '--platform chrome -i ./icon.png'])
    .description('Generate the home screen icons for a PWA')
    .option('--platform', 'Platform to generate for: safari, chrome')
    .action((inputProjectRoot, options) => {
    var _a;
    validateSourceArgument(options.input, 'favicon');
    const projectRoot = (inputProjectRoot !== null && inputProjectRoot !== void 0 ? inputProjectRoot : process.cwd());
    const output = (_a = options.output, (_a !== null && _a !== void 0 ? _a : path_1.join(projectRoot, 'web')));
    generateAssets(projectRoot, options.platform + '-icon', {
        src: options.input,
        output,
        publicPath: options.public || output,
        resizeMode: options.resize,
        color: options.color || 'transparent',
    })
        .then(update_1.default)
        .catch(commandDidThrowAsync);
});
assetCommand('favicon', ['-i ./icon.png'])
    .description('Generate the favicons for a website')
    .action((inputProjectRoot, options) => {
    var _a;
    validateSourceArgument(options.input, 'favicon');
    const projectRoot = (inputProjectRoot !== null && inputProjectRoot !== void 0 ? inputProjectRoot : process.cwd());
    const output = (_a = options.output, (_a !== null && _a !== void 0 ? _a : path_1.join(projectRoot, 'web')));
    generateAssets(projectRoot, 'favicon', {
        src: options.input,
        output,
        publicPath: options.public || output,
        resizeMode: options.resize,
        color: options.color || 'transparent',
    })
        .then(update_1.default)
        .catch(commandDidThrowAsync);
});
assetCommand('splash', ['--color blue --resize cover -i ./splash.png'])
    .description('Generate the Safari splash screens for a PWA')
    .action((inputProjectRoot, options) => {
    var _a;
    validateSourceArgument(options.input, 'favicon');
    const projectRoot = (inputProjectRoot !== null && inputProjectRoot !== void 0 ? inputProjectRoot : process.cwd());
    const output = (_a = options.output, (_a !== null && _a !== void 0 ? _a : path_1.join(projectRoot, 'web')));
    generateAssets(projectRoot, 'splash', {
        src: options.input,
        output,
        publicPath: options.public || output,
        resizeMode: options.resize,
        color: options.color || 'white',
    })
        .then(update_1.default)
        .catch(commandDidThrowAsync);
});
outputCommand('manifest', ['-i ./random.config.js'])
    .description('Generate the PWA manifest from an Expo project config')
    .action((inputProjectRoot, options) => {
    var _a, _b;
    const projectRoot = path_1.resolve((inputProjectRoot !== null && inputProjectRoot !== void 0 ? inputProjectRoot : process.cwd()));
    const output = (_a = options.output, (_a !== null && _a !== void 0 ? _a : path_1.join(projectRoot, 'web')));
    const publicPath = path_1.resolve((_b = options.public, (_b !== null && _b !== void 0 ? _b : output)));
    const outputPath = path_1.resolve(output);
    (() => __awaiter(void 0, void 0, void 0, function* () {
        const items = yield _1.generateManifestAsync({
            projectRoot: path_1.resolve(projectRoot),
            publicPath,
        }, options.input ? path_1.resolve(options.input) : undefined);
        yield resolveOutputAsync(publicPath, outputPath, items);
    }))()
        .then(update_1.default)
        .catch(commandDidThrowAsync);
});
program.parse(process.argv);
function generateAssets(projectRoot, type, { src, output, publicPath, color: backgroundColor, resizeMode = 'contain' }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isResizeMode(resizeMode)) {
            console.error(chalk_1.default.black.bgRed(`The provided resizeMode "${resizeMode}" is invalid. Please use one of [cover, contain]`));
            process.exit(-1);
        }
        const items = yield _1.generateAsync(type, { projectRoot: path_1.resolve(projectRoot || process.cwd()), publicPath: path_1.resolve(publicPath) }, { src, backgroundColor, resizeMode });
        const outputPath = path_1.resolve(output);
        yield resolveOutputAsync(publicPath, outputPath, items);
    });
}
function resolveOutputAsync(publicPath, outputPath, items) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(outputPath);
        let meta = [];
        let manifest = {};
        for (const item of items) {
            if (item.tag) {
                if ((_b = (_a = item.tag) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.href) {
                    item.tag.attributes.href = '/' + path_1.relative(publicPath, (_d = (_c = item.tag) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.href);
                }
                // Write HTML
                meta.push(HTML_1.htmlTagObjectToString(item.tag));
            }
            if (item.manifest) {
                // Write Manifest
                if (!Array.isArray(manifest.icons))
                    manifest.icons = [];
                if ((_e = item.manifest) === null || _e === void 0 ? void 0 : _e.src) {
                    item.manifest.src = '/' + path_1.relative(publicPath, item.manifest.src);
                }
                manifest.icons.push(item.manifest);
            }
            // Write image
            const assetPath = path_1.resolve(outputPath, item.asset.path);
            fs_extra_1.default.ensureDirSync(path_1.dirname(assetPath));
            yield fs_extra_1.default.writeFile(assetPath, item.asset.source);
        }
        if (meta.length) {
            logMeta(meta);
        }
        if (Object.keys(manifest).length) {
            logManifest(manifest);
        }
    });
}
function logManifest(manifest) {
    if (!Object.keys(manifest).length)
        return;
    console.log();
    console.log(chalk_1.default.magenta('\u203A Copy the following lines into your PWA `manifest.json` to link the new assets.'));
    console.log();
    console.log(JSON.stringify(manifest, null, 2));
    console.log();
}
function logMeta(meta) {
    if (!meta.length)
        return;
    console.log();
    console.log(chalk_1.default.magenta('\u203A Copy the following lines into your HTML <head/> to link the new assets.'));
    console.log();
    for (const metaLine of meta) {
        console.log(metaLine);
    }
    console.log();
}
function isResizeMode(input) {
    return input && ['contain', 'cover', 'fill', 'inside', 'outside'].includes(input);
}
function commandDidThrowAsync(reason) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log();
        console.log('Aborting run');
        if (reason.command) {
            console.log(`  ${chalk_1.default.magenta(reason.command)} has failed.`);
        }
        else {
            console.log(chalk_1.default.black.bgRed `An unexpected error was encountered. Please report it as a bug:`);
            console.log(reason);
        }
        console.log();
        yield update_1.default();
        process.exit(1);
    });
}
//# sourceMappingURL=cli.js.map