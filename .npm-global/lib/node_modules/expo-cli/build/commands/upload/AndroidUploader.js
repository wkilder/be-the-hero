"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _has() {
  const data = _interopRequireDefault(require("lodash/has"));

  _has = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _BaseUploader() {
  const data = _interopRequireDefault(require("./BaseUploader"));

  _BaseUploader = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PLATFORM = 'android';

const FILE_DOESNT_EXIST_ERROR = path => `File ${path} doesn't exist.`;

const SERVICE_ACCOUNT_JSON_QUESTION = {
  name: 'key',
  message: 'The path to the file containing service account JSON, used to authenticate with Google:',
  type: 'input',

  async validate(path) {
    const exists = await _fsExtra().default.pathExists(path);

    if (exists) {
      return true;
    } else {
      return FILE_DOESNT_EXIST_ERROR(path);
    }
  }

};

class AndroidUploader extends _BaseUploader().default {
  constructor(projectDir, options) {
    super(PLATFORM, projectDir, options);
    this.options = options;
  }

  _ensureExperienceIsValid(exp) {
    if (!(0, _has().default)(exp, 'android.package')) {
      throw new Error('You must specify an Android package in app.json.');
    }
  }

  async _getPlatformSpecificOptions() {
    const key = await this._getServiceAccountJSONPath();
    return {
      key,
      track: this.options.track
    };
  }

  async _getServiceAccountJSONPath() {
    const {
      key
    } = this.options;

    if (key && (await _fsExtra().default.pathExists(key))) {
      return key;
    } else {
      if (key) {
        (0, _log().default)(FILE_DOESNT_EXIST_ERROR(key));
      }

      return await this._askForServiceAccountJSONPath();
    }
  }

  async _askForServiceAccountJSONPath() {
    const answer = await (0, _prompt().default)(SERVICE_ACCOUNT_JSON_QUESTION);
    return answer.key;
  }

  async _uploadToTheStore(platformData, path) {
    var _this$_exp$android;

    const {
      fastlane
    } = this;
    const {
      key,
      track
    } = platformData;
    if (!this._exp) throw new Error('Expo Config is not defined');
    await (0, _utils().runFastlaneAsync)(fastlane.supplyAndroid, [path, (_this$_exp$android = this._exp.android) === null || _this$_exp$android === void 0 ? void 0 : _this$_exp$android.package, key, track], {});
  }

}

exports.default = AndroidUploader;
//# sourceMappingURL=../../__sourcemaps__/commands/upload/AndroidUploader.js.map
