"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findProjectRootAsync = findProjectRootAsync;
exports.validateGitStatusAsync = validateGitStatusAsync;

function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function findProjectRootAsync(base) {
  let previous = null;
  let dir = base;

  do {
    let pkgPath = _path().default.join(dir, 'package.json');

    let appJsonPath = _path().default.join(dir, 'app.json');

    let pkgExists = _fs().default.existsSync(pkgPath);

    let appJsonExists = _fs().default.existsSync(appJsonPath);

    if (pkgExists && appJsonExists) {
      let pkg = await _jsonFile().default.readAsync(pkgPath);
      let expo = await _jsonFile().default.getAsync(_path().default.join(dir, 'app.json'), 'expo', null);
      let workflow;

      if (expo && pkg.dependencies && pkg.dependencies.hasOwnProperty('react-native-unimodules')) {
        workflow = 'bare';
      } else if (!expo) {
        workflow = 'bare';
      } else {
        workflow = 'managed';
      }

      return {
        projectRoot: dir,
        workflow
      };
    } else if (pkgExists && !appJsonExists) {
      return {
        projectRoot: dir,
        workflow: 'bare'
      };
    }

    previous = dir;
    dir = _path().default.dirname(dir);
  } while (dir !== previous);

  throw new (_CommandError().default)('NO_PROJECT', 'No managed or bare projects found. Please make sure you are inside a project folder.');
}

async function validateGitStatusAsync() {
  let workingTreeStatus = 'unknown';

  try {
    let result = await (0, _spawnAsync().default)('git', ['status', '--porcelain']);
    workingTreeStatus = result.stdout === '' ? 'clean' : 'dirty';
  } catch (e) {// Maybe git is not installed?
    // Maybe this project is not using git?
  }

  if (workingTreeStatus === 'clean') {
    _log().default.nested(`Your git working tree is ${_chalk().default.green('clean')}`);

    _log().default.nested('To revert the changes after this command completes, you can run the following:');

    _log().default.nested('  git clean --force && git reset --hard');

    return true;
  } else if (workingTreeStatus === 'dirty') {
    _log().default.nested(`${_chalk().default.bold('Warning!')} Your git working tree is ${_chalk().default.red('dirty')}.`);

    _log().default.nested(`It's recommended to ${_chalk().default.bold('commit all your changes before proceeding')},\nso you can revert the changes made by this command if necessary.`);
  } else {
    _log().default.nested("We couldn't find a git repository in your project directory.");

    _log().default.nested("It's recommended to back up your project before proceeding.");
  }

  return false;
}
//# sourceMappingURL=../../__sourcemaps__/commands/utils/ProjectUtils.js.map
